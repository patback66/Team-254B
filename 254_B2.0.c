#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  armEncoder,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  side,           sensorTouch)
#pragma config(Sensor, dgtl4,  button,         sensorTouch)
#pragma config(Sensor, I2C_1,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           bLeft,         tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           bRight,        tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           aLeft,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           rollersLeft,   tmotorVex269, openLoop)
#pragma config(Motor,  port5,           strafeLeft,    tmotorVex269, openLoop)
#pragma config(Motor,  port6,           strafeRight,   tmotorVex269, openLoop)
#pragma config(Motor,  port7,           rollersRight,  tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port8,           aRight,        tmotorVex393, openLoop)
#pragma config(Motor,  port9,           fRight,        tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port10,          fLeft,         tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//nMotorEncoder[bLeft];
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Variable Declarations
//Constants for Autonomous
const float circumference = 12.6;
const int encoderCounts = 360;
const int integratedEncoderCounts = 627.2; //392;
//Constants for PID
//.5, .5, .5
float arm_kP=0.05, arm_kI=0.05, arm_kD=0.05;
float drive_kP=0.05, drive_kI=0.05, drive_kD=0.05;
//PID error variables
float arm_errorSum=0, arm_lastError=0;
float drive_errorSum=0, drive_lastError=0;

//Function declarations

//PID Functions
float UpdateD(float goal, float currentValue) {//driver pid
  float error = goal - currentValue;
  float p = drive_kP * error;
  drive_errorSum += error;
  float i = drive_kI * drive_errorSum;
  float dError = error - drive_lastError;
  float d = drive_kD * dError;
  drive_lastError = error;
  return p + i + d;
}

void resetDrivePID () {
  nMotorEncoder[bLeft] = 0;
  nMotorEncoder[bRight] = 0;
  drive_errorSum = 0;
  drive_lastError = 0;
}
float UpdateA(float goal, float currentValue) {//arm pid
  float error = goal - currentValue;
  float p = arm_kP * error;
  arm_errorSum += error;
  float i = arm_kI * arm_errorSum;
  float dError = error - arm_lastError;
  float d = arm_kD * dError;
  arm_lastError = error;
  return p + i + d;
}
;
//Autonomous and General Functions
int distanceToCounts(float distance, int i)
{
    int counts;
    if(i == 0){ //arm encoder is case 0
		  counts = distance / circumference * encoderCounts;
		  return counts;
	  }
	  else{ //driver encoder is case 1
	    counts = distance / circumference * integratedEncoderCounts;
		  return counts;
	  }
}
float leftdistance()
{
	return nMotorEncoder[bLeft] / (encoderCounts) * (4*PI);
}
float rightdistance()
{
	return nMotorEncoder[bRight] / (encoderCounts) * (4*PI);
}

void clearEncoders()
{

}
void motorUnity (int group, int power)
{

    if (abs (power) <= 10) //threshold
		{
			power=0;
		}
		switch(group)
		{
			case 0: //Left Drive
			  //resetDrivePID();
				motor[fLeft] = power;
				motor[bLeft] = power;
				break;
			case 1: //Right Drive
			  //resetDrivePID();
				motor[fRight] = power;
				motor[bRight] = power;
				break;
			case 2: //Arm
				motor[aLeft] = power;
				motor[aRight] = power;
				break;
			case 3: //Rollers
				motor[rollersLeft] = power;
				motor[rollersRight] = power;
				break;
			case 4:
			  motor[strafeLeft] = power;
			  motor[strafeRight] = power;
			  //strafing motor
			  break;
      case 5:
        if(SensorValue[armEncoder] + 253 > 10)
        {
          motor[aLeft] = 127;
          motor[aRight] = 127;
        }
        else if (SensorValue[armEncoder] + 253 > 0)
        {
          motor[aLeft] = 20;
          motor[aRight] = 20;
        }
        else if (SensorValue[armEncoder] + 253 < -25)
        {
          motor[aLeft] = -45;
          motor[aRight] = -45;
        }
        else if (SensorValue[armEncoder] + 253 < 0)
        {
          motor[aLeft] = -20;
          motor[aRight] = -20;
        }
        else
        {
          motor[aLeft] = 0;
          motor[aRight] = 0;
        }
        break;
		}
		//robwashere :)
}
void pidForward(int powR, int powL) {
   float rightEncode = nMotorEncoder[bRight], leftEncode = nMotorEncoder[bLeft];
   float mod = UpdateD( rightEncode, leftEncode);
   powL = powL + (5 * mod / integratedEncoderCounts);
   //powL = powL - (5 * mod / integratedEncoderCounts);
   powL = powL % 127;
   powR = powR % 127;
   motor[fLeft] = powL;
	 motor[bLeft] = powL;
	 motor[fRight] = powR;
	 motor[bRight] = powR;

}
float dist;
void straightDrive(float inches, int speed)
{
  nMotorEncoder[bLeft] = 0;
  nMotorEncoder[bRight] = 0;
	while(true)
	{
		dist=abs(rightdistance());
	  if (inches>0){
			if (dist<inches){
			  pidForward(speed, speed);
				//motorUnity(0, speed);
				//motorUnity(1, speed);
			}
	   	else{
	  		motorUnity(0, 0);
	  		motorUnity(1, 0);
	 			break;
	 		}
	 	}
	 	if (inches < 0){
			if (dist<inches){
			  pidForward(-speed, -speed);
			  //motorUnity(1, -speed);
			 // motorUnity(0, -speed);
			}
	   	else{
	   	  motorUnity(0, 0);
	   	  motorUnity(1, 0);
	 			break;
	 		}
	  }
	}
}

void holdArm()
{
}
void autoFunctions()
{
  //Insert autonomous routine
}
void basicAuto()
{
  motorUnity(3, 127);
  wait10Msec(300);
  motorUnity(3, 0);
}
void slightlyMoreAdvancedAuto()
{
  motorUnity(3, 127);
  wait10Msec(100);
  motorUnity(3,0);
  straightDrive(1, 127);
}
void scoringAuto()
{
  nMotorEncoder[bLeft] = 0;
  nMotorEncoder[bRight] = 0;
  motorUnity(3, 127);
  if(SensorValue[side] == 1)//right
  {
    while(nMotorEncoder[bRight] < distanceToCounts(38,1))
    {
      motorUnity(0,120);
      motorUnity(1,127);
      if(nMotorEncoder[bRight] > distanceToCounts(14,1))
      {
        motorUnity(3, -127);
        motorUnity(0, 90);
        motorUnity(1, 90);
      }
    }
    motorUnity(0, 0);
    motorUnity(1, 0);
    nMotorEncoder[bLeft] = 0;
    nMotorEncoder[bRight] = 0;
    while(SensorValue[armEncoder] > -220)
    {
      motorUnity(5, 127);
    }
    motorUnity(2, 0);
    while(nMotorEncoder[bLeft] < distanceToCounts(13, 1))
    {
      motorUnity(0, 127);
      motorUnity(1, 11);
    }
    motorUnity(0, 0);
    motorUnity(2, 0);
    nMotorEncoder[bLeft] = 0;
    nMotorEncoder[bRight] = 0;

    while(nMotorEncoder[bRight] < distanceToCounts(7, 1))
    {
      motorUnity(0, 35);
      motorUnity(1, 35);
    }
    motorUnity(0, 0);
    motorUnity(1, 0);
    motorUnity(3, 127);
    wait10Msec(300);
    motorUnity(3, 0);
  }
  else if(SensorValue[side] == 0)//left
  {
    while(nMotorEncoder[bRight] < distanceToCounts(34,1))
    {
      motorUnity(0,127);
      motorUnity(1,80);
      if(nMotorEncoder[bRight] > distanceToCounts(14,1))
         motorUnity(3, -127);
    }
    motorUnity(0, 0);
    motorUnity(1, 0);
    nMotorEncoder[bLeft] = 0;
    nMotorEncoder[bRight] = 0;
    while(SensorValue[armEncoder] > -218)
    {
      motorUnity(5, 127);
    }
    motorUnity(2, 0);
    while(nMotorEncoder[bRight] < distanceToCounts(7, 1))
    {
      motorUnity(0, 11);
      motorUnity(1, 127);
    }
    motorUnity(0, 0);
    motorUnity(3, 0);
    nMotorEncoder[bLeft] = 0;
    nMotorEncoder[bRight] = 0;

    while(nMotorEncoder[bRight] < distanceToCounts(7, 1))
    {
      motorUnity(0, 30);
      motorUnity(1, 30);
    }
    motorUnity(2, -40);
    motorUnity(0, 0);
    motorUnity(1, 0);
    motorUnity(3, 127);
    motorUnity(2, 0);
    wait10Msec(300);
    motorUnity(3, 0);
  }
}
void wubble()
{
  nMotorEncoder[bRight] = 0;
  nMotorEncoder[bLeft] = 0;
  while(nMotorEncoder[bRight] < distanceToCounts(7, 1))
  {
    motorUnity(0, -80);
    motorUnity(1, 80);
  }
  nMotorEncoder[bRight] = 0;
  nMotorEncoder[bLeft] = 0;
  while(nMotorEncoder[bLeft] < distanceToCounts(7, 1))
  {
    motorUnity(0, 80);
    motorUnity(1, -80);
  }
  nMotorEncoder[bLeft] = 0;
  nMotorEncoder[bRight] = 0;
  motorUnity(0, 0);
  motorUnity(1, 0);
  while(nMotorEncoder[bRight] < distanceToCounts(2, 1))
  {
      motorUnity(0, 80);
      motorUnity(1, 80);
  }
  nMotorEncoder[bLeft] = 0;
  nMotorEncoder[bRight] = 0;
}
void programmingSkills()
{
  nMotorEncoder[bRight] = 0;
  nMotorEncoder[bLeft] = 0;
  SensorValue[armEncoder] = 0;

  //Step 1, to trough and score, return
  motorUnity(3, 127);
  wait10Msec(30);
  motorUnity(3, 0);
  while(nMotorEncoder[bRight] < distanceToCounts(20, 1))
  {
     motorUnity(1, 120);
     motorUnity(0, 127);
  }
  motorUnity(0, 0);
  motorUnity(1, 0);
  while(SensorValue[armEncoder] > -225)
  {
    motorUnity(5, 120);
  }
   motorUnity(2, 0);
   nMotorEncoder[bRight] = 0;
   nMotorEncoder[bLeft] = 0;
   while(nMotorEncoder[bRight] < distanceToCounts(25, 1))
   {
     motorUnity(0, 90);
     motorUnity(1, 90);
   }
   motorUnity(0, 0);
   motorUnity(1, 0);
   motorUnity(2, 11);
   motorUnity(3, 127);
   wait10Msec(300);
   motorUnity(3, 0);
   nMotorEncoder[bLeft] = 0;
   nMotorEncoder[bRight] = 0;
   while(nMotorEncoder[bRight] > -distanceToCounts(15, 1))
   {
     motorUnity(0, -127);
     motorUnity(1, -127);
     if(nMotorEncoder[bRight] < -400)
     {
      while(SensorValue[armEncoder] < 0)
      {
          motorUnity(2, -127);
      }
     }
     motorUnity(2, 0);
   }
   motorUnity(0, 0);
   motorUnity(1, 0);
   nMotorEncoder[bRight] = 0;
   nMotorEncoder[bLeft] = 0;
   SensorValue[armEncoder] = 0;
   /*
   motorUnity(3, -127);
   while(nMotorEncoder[bRight] < distanceToCounts(20, 1))
   {
     motorUnity(0, 127);
     motorUnity(1, 127);
   }
   motorUnity(0, 0);
   motorUnity(1, 0);
   wait10Msec(100);
   nMotorEncoder[bRight] = 0;
   nMotorEncoder[bLeft] = 0;
   while(nMotorEncoder[bRight] > -distanceToCounts(8, 1))
   {
     motorUnity(0, -127);
     motorUnity(1, -127);
   }
   motorUnity(0, 0);
   motorUnity(1, 0);
   nMotorEncoder[bRight] = 0;
   nMotorEncoder[bLeft] = 0;
   while(SensorValue[armEncoder] > -218)
   {
     motorUnity(5, 127);
   }
   motorUnity(5, 0);
   while(nMotorEncoder[bRight] < distanceToCounts(12, 1))
   {
     motorUnity(0, 127);
     motorUnity(1, 127);
   }
   motorUnity(0, 0);
   motorUnity(1, 0);
   nMotorEncoder[bRight] = 0;
   nMotorEncoder[bLeft] = 0;
   motorUnity(3, -127);
   wait10Msec(200);
   motorUnity(3, 0);
   while( nMotorEncoder[bRight] > -distanceToCounts(40, 1))
   {
     motorUnity(0, -127);
     motorUnity(1, -127);
     if(nMotorEncoder[bRight] < - 500)
     {
       while(SensorValue[armEncoder] < 0)
      {
          motorUnity(2, -127);
      }
     }
     motorUnity(2, 0);
   }
   motorUnity(0, 0);
   motorUnity(1, 0);
   */
   //reposition, wait for button push
   //Step 2
   /*
   while(!SensorValue[button])
   {}
   wait1Msec(50);
   nMotorEncoder[bLeft] = 0;
   nMotorEncoder[bRight] = 0;
   SensorValue[armEncoder] = 0;
   motorUnity(3, -127);
   while(nMotorEncoder[bRight] < distanceToCounts(21, 1))
   {
      motorUnity(0, 127);
      motorUnity(1, 120);
   }
   nMotorEncoder[bLeft] = 0;
   nMotorEncoder[bRight] = 0;
   for(int i = 0; i < 5; i++)
     wubble();
   nMotorEncoder[bLeft] = 0;
   nMotorEncoder[bRight] = 0;
   SensorValue[armEncoder] = 0;
   while(nMotorEncoder[bRight] > -distanceToCounts(10, 1))
   {
     motorUnity(0, -127);
     motorUnity(1, -127);
   }
   motorUnity(0,0);
   motorUnity(1, 0);
   while(SensorValue[armEncoder] > -218)
   {
     motorUnity(5, 127);
   }
   motorUnity(2, 11);
   nMotorEncoder[bLeft] = 0;
   nMotorEncoder[bRight] = 0;

   while(nMotorEncoder[bRight] < distanceToCounts(30,1))
   {
     motorUnity(0,120);
     motorUnity(1,127);
   }
   motorUnity(0, 0);
   motorUnity(1, 0);
   nMotorEncoder[bLeft] = 0;
   nMotorEncoder[bRight] = 0;
   motorUnity(3, 127);
   wait10Msec(300);
   motorUnity(3, 0);
   while(nMotorEncoder[bRight] > -distanceToCounts(40, 1))
   {
     motorUnity(0, -127);
     motorUnity(1, -127);
     while(SensorValue[armEncoder] > 0 && nMotorEncoder[bRight] > - 600)
       motorUnity(2, -127);
     motorUnity(2, 0);
   }
   motorUnity(0, 0);
   motorUnity(1, 0);
   */
   //Stage 3: get high goal
   while(!SensorValue[button])
   {}
   wait1Msec(10);
   nMotorEncoder[bRight] = 0;
   nMotorEncoder[bLeft] = 0;
   while(nMotorEncoder[bRight] < distanceToCounts(39,1))
    {
      motorUnity(0,120);
      motorUnity(1,127);
      if(nMotorEncoder[bRight] > distanceToCounts(14,1))
      {
        motorUnity(3, -127);
        motorUnity(0, 90);
        motorUnity(1, 90);
      }
    }
    motorUnity(0, 0);
    motorUnity(1, 0);
    wait10Msec(80);
    nMotorEncoder[bLeft] = 0;
    nMotorEncoder[bRight] = 0;
    while(SensorValue[armEncoder] > -218)
    {
      motorUnity(5, 100);
    }
    motorUnity(2, 0);
    while(nMotorEncoder[bLeft] < distanceToCounts(10, 1))
    {
      motorUnity(0, 127);
      motorUnity(1, 11);
    }
    motorUnity(0, 0);
    motorUnity(2, 0);
    nMotorEncoder[bLeft] = 0;
    nMotorEncoder[bRight] = 0;

    while(nMotorEncoder[bRight] < distanceToCounts(15, 1))
    {
      motorUnity(0, 35);
      motorUnity(1, 35);
    }
    motorUnity(2, -40);
    motorUnity(0, 0);
    motorUnity(1, 0);
    motorUnity(3, 127);
    motorUnity(2, 0);
    wait10Msec(300);
    motorUnity(3, 0);
}






void basicDriver()
{

    //Basic Driver + Operator controls
    motorUnity (0,vexRT[Ch3]); //Left
		motorUnity (1,vexRT[Ch2]); //Right

	  motorUnity (3,vexRT[Ch2Xmtr2]); //Rollers

	  if(vexRT[Btn6U])
	  {
	     motorUnity(4, 127);
	  } else if(vexRT[Btn5U])
	  {
	     motorUnity(4, -127);
	  } else
	  {
	    motorUnity(4, 0);
	  }
	  //hold arm
	  if(vexRT[Btn5UXmtr2])
	  {
	    motorUnity(2, 30);
	  }
	  else if (vexRT[Btn6UXmtr2])
	  {
	     motorUnity(2, 20);
	  }
	  else if(vexRT[Btn7DXmtr2])//arm upright
	  {
	      motorUnity(5,127);
	  }
	  else
	  {
      motorUnity (2,vexRT[Ch3Xmtr2]); //Arm
	  }

}
void pidDrive()
{
    if(abs(vexRT[Ch2]) > 10 && abs(vexRT[Ch3]) > 10 && abs(vexRT[Ch2]-vexRT[Ch3]) < 3 )
      pidForward (vexRT[Ch2], vexRT[Ch3]);
    //Basic Driver + Operator controls
    else {
      motorUnity (0,vexRT[Ch3]); //Left
		  motorUnity (1,vexRT[Ch2]); //Right
		}

	  motorUnity (3,vexRT[Ch2Xmtr2]); //Rollers
	  if(vexRT[Btn6U])
	  {
	     motorUnity(4, 127);
	  } else if(vexRT[Btn5U])
	  {
	     motorUnity(4, -127);
	  } else
	  {
	    motorUnity(4, 0);
	  }
	  //hold arm
	  if(vexRT[Btn5UXmtr2])
	  {
	    motorUnity(2, 30);
	  }
	  else if (vexRT[Btn6UXmtr2])
	  {
	     motorUnity(2, 20);
	  }
	  else
	  {
      motorUnity (2,vexRT[Ch3Xmtr2]); //Arm
	  }
    //Insert controls for driver & operator control with PID
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
  clearEncoders();

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

  //motorUnity(3, 127);
  //basicAuto();
  //scoringAuto();
  programmingSkills();
  //motorUnity(3, 127);
	//AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
	  basicDriver();
	  //pidDrive();
	}
}
